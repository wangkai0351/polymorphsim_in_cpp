# 导读

本书在章节的起承转合上有密切的配合，所以并不建议你做跳跃式阅读。从第一页按照顺序看到最后一页，是我认为比较好的阅读方式。当然，如果你对于某些主题十分熟稔，可以快速掠过进入下一主题。

## 读者基础

你需要一些C++语言基础，以及程序设计领域的某种重要的经验。这种经验很难加以量化，你可以试着找出本书中你最感兴趣或最有心得的一部分，试读3～5页。如果读来顺畅，有所领悟，就带回家去吧。

## 章节划分

本书共分为六章：

### 第一章 classes语法和语意

本章内容都围绕着C++ classes展开。本章对C++ Classes的重要性质做了一个梗概描述，算是搭建起了你（读者）和我（作者）之间的共识。这些C++语法和语义大部分都是后续章节需要用到的。小部分虽然与后续章节无关，却是

### 第二章 C++对象模型（C++ Object Model）

C++对象模型的技术涵盖的范围很广，本章只挑选和“多态与虚拟”有关的两大主题：（1）对象实体的布局，（2）虚拟机制的底层架构（vptr和vtbl）。这一章可以为你打下非常扎实的底层基础，使你在面对一个虚函数时，清楚它何时被唤起，它的额外负担时什么、以及为什么能够靠它达到多态的终极目标。

### 第三章 类型转换（Type Casting）

一旦引入多态，对象指标必须考虑类型安全（type-safe）的问题。本章介绍C++的三个转换运算符，并把焦点放在和RTTI有关的*dynamic_cast*运算符上。本章也介绍了C/C++ Standard的#和##运算符（或者你可以称它们为编译器的前置处理器），帮助我们利用编译器为我们“写程序”，#和##这两个运算符在第五章的程序实例中扮演重要的角色。

### 第四章 为什么需要多态（Why Polymorphism）

本章利用一个小例子，解释虚函数带来的影响，以及多态（polymorphism）的无限

### 第五章 Polymorphism的应用



### 第六章 从C++ Object Model迈向Component Object Model

C++有其可到之处，也有其不可到之处。

## 使用工具

理论上，任何一个C++编译器，都可以编译本书的任何一个程序。即使第五章那个脱自Microsoft Fundation Classes（MFC）的大型实例，经过我的修改，一样可以通过各家编译器。我的实验平台包括Visual C++和Borland Builder两套C++编译器。

前三章介绍各种语法或各种低阶实验性操作时，常会连带把测试操作的编译错误提示信息列出（如果有的话）。我所列的是Microsoft Visual C++的错误提示信息和代码。

目前PC上任意一套C++编译器都能提供集成开发环境（IDE）以及命令行（command line）两种模式。本书第2章p.150和第5章p.233分别示范了在Visual C++环境下如何设定并使用这两种模式。

## 程序代码

第5章和第6章有实例程序，比较大也比较值得提供给读者。我把它放在松岗出版公司的网站上（http://www.unalis.com.tw ），清自行下载。至于分散在本书各处的小小测试程序，非常多，非常小，非常琐碎，并不打算提供给读者。

## 用词特色

C++以及面向对象领域的一个特色就是，有着多如牛毛的术语，而且又臭又长。我决定尽量采用英文术语，原因有二：

1. 我清楚工程师们的习惯用语，我不想让他们看这本书时，常常得把中文名词翻译回去，或常常得查阅中英名词对照表。
2. 学生们对于英文术语的陌生程度已经到了另我惊骇的地步，我希望起一些引导作用。

当然，中英名词的取舍与选择，程度上的拿捏是很需要技巧的，而选择是很带个人色彩的。欢迎您给我提意见，谢谢。

​											       侯俊杰 1998.078.02于新竹

​													jjh@ccca.nctu.edu.tw